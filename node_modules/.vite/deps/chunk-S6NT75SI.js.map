{
  "version": 3,
  "sources": ["../../three/examples/jsm/utils/GeometryCompressionUtils.js", "../../three/examples/jsm/utils/PackedPhongMaterial.js"],
  "sourcesContent": ["/**\r\n * Octahedron and Quantization encodings based on work by:\r\n *\r\n * @link https://github.com/tsherif/mesh-quantization-example\r\n *\r\n */\r\n\r\nimport {\r\n\tBufferAttribute,\r\n\tMatrix3,\r\n\tMatrix4,\r\n\tVector3\r\n} from 'three';\r\nimport { PackedPhongMaterial } from './PackedPhongMaterial.js';\r\n\r\n\r\n\r\n/**\r\n * Make the input mesh.geometry's normal attribute encoded and compressed by 3 different methods.\r\n * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the normal data.\r\n *\r\n * @param {THREE.Mesh} mesh\r\n * @param {String} encodeMethod\t\t\"DEFAULT\" || \"OCT1Byte\" || \"OCT2Byte\" || \"ANGLES\"\r\n *\r\n */\r\nfunction compressNormals( mesh, encodeMethod ) {\r\n\r\n\tif ( ! mesh.geometry ) {\r\n\r\n\t\tconsole.error( 'Mesh must contain geometry. ' );\r\n\r\n\t}\r\n\r\n\tconst normal = mesh.geometry.attributes.normal;\r\n\r\n\tif ( ! normal ) {\r\n\r\n\t\tconsole.error( 'Geometry must contain normal attribute. ' );\r\n\r\n\t}\r\n\r\n\tif ( normal.isPacked ) return;\r\n\r\n\tif ( normal.itemSize != 3 ) {\r\n\r\n\t\tconsole.error( 'normal.itemSize is not 3, which cannot be encoded. ' );\r\n\r\n\t}\r\n\r\n\tconst array = normal.array;\r\n\tconst count = normal.count;\r\n\r\n\tlet result;\r\n\tif ( encodeMethod == 'DEFAULT' ) {\r\n\r\n\t\t// TODO: Add 1 byte to the result, making the encoded length to be 4 bytes.\r\n\t\tresult = new Uint8Array( count * 3 );\r\n\r\n\t\tfor ( let idx = 0; idx < array.length; idx += 3 ) {\r\n\r\n\t\t\tconst encoded = defaultEncode( array[ idx ], array[ idx + 1 ], array[ idx + 2 ], 1 );\r\n\r\n\t\t\tresult[ idx + 0 ] = encoded[ 0 ];\r\n\t\t\tresult[ idx + 1 ] = encoded[ 1 ];\r\n\t\t\tresult[ idx + 2 ] = encoded[ 2 ];\r\n\r\n\t\t}\r\n\r\n\t\tmesh.geometry.setAttribute( 'normal', new BufferAttribute( result, 3, true ) );\r\n\t\tmesh.geometry.attributes.normal.bytes = result.length * 1;\r\n\r\n\t} else if ( encodeMethod == 'OCT1Byte' ) {\r\n\r\n\t\t/**\r\n\t\t* It is not recommended to use 1-byte octahedron normals encoding unless you want to extremely reduce the memory usage\r\n\t\t* As it makes vertex data not aligned to a 4 byte boundary which may harm some WebGL implementations and sometimes the normal distortion is visible\r\n\t\t* Please refer to @zeux 's comments in https://github.com/mrdoob/three.js/pull/18208\r\n\t\t*/\r\n\r\n\t\tresult = new Int8Array( count * 2 );\r\n\r\n\t\tfor ( let idx = 0; idx < array.length; idx += 3 ) {\r\n\r\n\t\t\tconst encoded = octEncodeBest( array[ idx ], array[ idx + 1 ], array[ idx + 2 ], 1 );\r\n\r\n\t\t\tresult[ idx / 3 * 2 + 0 ] = encoded[ 0 ];\r\n\t\t\tresult[ idx / 3 * 2 + 1 ] = encoded[ 1 ];\r\n\r\n\t\t}\r\n\r\n\t\tmesh.geometry.setAttribute( 'normal', new BufferAttribute( result, 2, true ) );\r\n\t\tmesh.geometry.attributes.normal.bytes = result.length * 1;\r\n\r\n\t} else if ( encodeMethod == 'OCT2Byte' ) {\r\n\r\n\t\tresult = new Int16Array( count * 2 );\r\n\r\n\t\tfor ( let idx = 0; idx < array.length; idx += 3 ) {\r\n\r\n\t\t\tconst encoded = octEncodeBest( array[ idx ], array[ idx + 1 ], array[ idx + 2 ], 2 );\r\n\r\n\t\t\tresult[ idx / 3 * 2 + 0 ] = encoded[ 0 ];\r\n\t\t\tresult[ idx / 3 * 2 + 1 ] = encoded[ 1 ];\r\n\r\n\t\t}\r\n\r\n\t\tmesh.geometry.setAttribute( 'normal', new BufferAttribute( result, 2, true ) );\r\n\t\tmesh.geometry.attributes.normal.bytes = result.length * 2;\r\n\r\n\t} else if ( encodeMethod == 'ANGLES' ) {\r\n\r\n\t\tresult = new Uint16Array( count * 2 );\r\n\r\n\t\tfor ( let idx = 0; idx < array.length; idx += 3 ) {\r\n\r\n\t\t\tconst encoded = anglesEncode( array[ idx ], array[ idx + 1 ], array[ idx + 2 ] );\r\n\r\n\t\t\tresult[ idx / 3 * 2 + 0 ] = encoded[ 0 ];\r\n\t\t\tresult[ idx / 3 * 2 + 1 ] = encoded[ 1 ];\r\n\r\n\t\t}\r\n\r\n\t\tmesh.geometry.setAttribute( 'normal', new BufferAttribute( result, 2, true ) );\r\n\t\tmesh.geometry.attributes.normal.bytes = result.length * 2;\r\n\r\n\t} else {\r\n\r\n\t\tconsole.error( 'Unrecognized encoding method, should be `DEFAULT` or `ANGLES` or `OCT`. ' );\r\n\r\n\t}\r\n\r\n\tmesh.geometry.attributes.normal.needsUpdate = true;\r\n\tmesh.geometry.attributes.normal.isPacked = true;\r\n\tmesh.geometry.attributes.normal.packingMethod = encodeMethod;\r\n\r\n\t// modify material\r\n\tif ( ! ( mesh.material instanceof PackedPhongMaterial ) ) {\r\n\r\n\t\tmesh.material = new PackedPhongMaterial().copy( mesh.material );\r\n\r\n\t}\r\n\r\n\tif ( encodeMethod == 'ANGLES' ) {\r\n\r\n\t\tmesh.material.defines.USE_PACKED_NORMAL = 0;\r\n\r\n\t}\r\n\r\n\tif ( encodeMethod == 'OCT1Byte' ) {\r\n\r\n\t\tmesh.material.defines.USE_PACKED_NORMAL = 1;\r\n\r\n\t}\r\n\r\n\tif ( encodeMethod == 'OCT2Byte' ) {\r\n\r\n\t\tmesh.material.defines.USE_PACKED_NORMAL = 1;\r\n\r\n\t}\r\n\r\n\tif ( encodeMethod == 'DEFAULT' ) {\r\n\r\n\t\tmesh.material.defines.USE_PACKED_NORMAL = 2;\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n\t * Make the input mesh.geometry's position attribute encoded and compressed.\r\n\t * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the position data.\r\n\t *\r\n\t * @param {THREE.Mesh} mesh\r\n\t *\r\n\t */\r\nfunction compressPositions( mesh ) {\r\n\r\n\tif ( ! mesh.geometry ) {\r\n\r\n\t\tconsole.error( 'Mesh must contain geometry. ' );\r\n\r\n\t}\r\n\r\n\tconst position = mesh.geometry.attributes.position;\r\n\r\n\tif ( ! position ) {\r\n\r\n\t\tconsole.error( 'Geometry must contain position attribute. ' );\r\n\r\n\t}\r\n\r\n\tif ( position.isPacked ) return;\r\n\r\n\tif ( position.itemSize != 3 ) {\r\n\r\n\t\tconsole.error( 'position.itemSize is not 3, which cannot be packed. ' );\r\n\r\n\t}\r\n\r\n\tconst array = position.array;\r\n\tconst encodingBytes = 2;\r\n\r\n\tconst result = quantizedEncode( array, encodingBytes );\r\n\r\n\tconst quantized = result.quantized;\r\n\tconst decodeMat = result.decodeMat;\r\n\r\n\t// IMPORTANT: calculate original geometry bounding info first, before updating packed positions\r\n\tif ( mesh.geometry.boundingBox == null ) mesh.geometry.computeBoundingBox();\r\n\tif ( mesh.geometry.boundingSphere == null ) mesh.geometry.computeBoundingSphere();\r\n\r\n\tmesh.geometry.setAttribute( 'position', new BufferAttribute( quantized, 3 ) );\r\n\tmesh.geometry.attributes.position.isPacked = true;\r\n\tmesh.geometry.attributes.position.needsUpdate = true;\r\n\tmesh.geometry.attributes.position.bytes = quantized.length * encodingBytes;\r\n\r\n\t// modify material\r\n\tif ( ! ( mesh.material instanceof PackedPhongMaterial ) ) {\r\n\r\n\t\tmesh.material = new PackedPhongMaterial().copy( mesh.material );\r\n\r\n\t}\r\n\r\n\tmesh.material.defines.USE_PACKED_POSITION = 0;\r\n\r\n\tmesh.material.uniforms.quantizeMatPos.value = decodeMat;\r\n\tmesh.material.uniforms.quantizeMatPos.needsUpdate = true;\r\n\r\n}\r\n\r\n/**\r\n * Make the input mesh.geometry's uv attribute encoded and compressed.\r\n * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the uv data.\r\n *\r\n * @param {THREE.Mesh} mesh\r\n *\r\n */\r\nfunction compressUvs( mesh ) {\r\n\r\n\tif ( ! mesh.geometry ) {\r\n\r\n\t\tconsole.error( 'Mesh must contain geometry property. ' );\r\n\r\n\t}\r\n\r\n\tconst uvs = mesh.geometry.attributes.uv;\r\n\r\n\tif ( ! uvs ) {\r\n\r\n\t\tconsole.error( 'Geometry must contain uv attribute. ' );\r\n\r\n\t}\r\n\r\n\tif ( uvs.isPacked ) return;\r\n\r\n\tconst range = { min: Infinity, max: - Infinity };\r\n\r\n\tconst array = uvs.array;\r\n\r\n\tfor ( let i = 0; i < array.length; i ++ ) {\r\n\r\n\t\trange.min = Math.min( range.min, array[ i ] );\r\n\t\trange.max = Math.max( range.max, array[ i ] );\r\n\r\n\t}\r\n\r\n\tlet result;\r\n\r\n\tif ( range.min >= - 1.0 && range.max <= 1.0 ) {\r\n\r\n\t\t// use default encoding method\r\n\t\tresult = new Uint16Array( array.length );\r\n\r\n\t\tfor ( let i = 0; i < array.length; i += 2 ) {\r\n\r\n\t\t\tconst encoded = defaultEncode( array[ i ], array[ i + 1 ], 0, 2 );\r\n\r\n\t\t\tresult[ i ] = encoded[ 0 ];\r\n\t\t\tresult[ i + 1 ] = encoded[ 1 ];\r\n\r\n\t\t}\r\n\r\n\t\tmesh.geometry.setAttribute( 'uv', new BufferAttribute( result, 2, true ) );\r\n\t\tmesh.geometry.attributes.uv.isPacked = true;\r\n\t\tmesh.geometry.attributes.uv.needsUpdate = true;\r\n\t\tmesh.geometry.attributes.uv.bytes = result.length * 2;\r\n\r\n\t\tif ( ! ( mesh.material instanceof PackedPhongMaterial ) ) {\r\n\r\n\t\t\tmesh.material = new PackedPhongMaterial().copy( mesh.material );\r\n\r\n\t\t}\r\n\r\n\t\tmesh.material.defines.USE_PACKED_UV = 0;\r\n\r\n\t} else {\r\n\r\n\t\t// use quantized encoding method\r\n\t\tresult = quantizedEncodeUV( array, 2 );\r\n\r\n\t\tmesh.geometry.setAttribute( 'uv', new BufferAttribute( result.quantized, 2 ) );\r\n\t\tmesh.geometry.attributes.uv.isPacked = true;\r\n\t\tmesh.geometry.attributes.uv.needsUpdate = true;\r\n\t\tmesh.geometry.attributes.uv.bytes = result.quantized.length * 2;\r\n\r\n\t\tif ( ! ( mesh.material instanceof PackedPhongMaterial ) ) {\r\n\r\n\t\t\tmesh.material = new PackedPhongMaterial().copy( mesh.material );\r\n\r\n\t\t}\r\n\r\n\t\tmesh.material.defines.USE_PACKED_UV = 1;\r\n\r\n\t\tmesh.material.uniforms.quantizeMatUV.value = result.decodeMat;\r\n\t\tmesh.material.uniforms.quantizeMatUV.needsUpdate = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n// Encoding functions\r\n\r\nfunction defaultEncode( x, y, z, bytes ) {\r\n\r\n\tif ( bytes == 1 ) {\r\n\r\n\t\tconst tmpx = Math.round( ( x + 1 ) * 0.5 * 255 );\r\n\t\tconst tmpy = Math.round( ( y + 1 ) * 0.5 * 255 );\r\n\t\tconst tmpz = Math.round( ( z + 1 ) * 0.5 * 255 );\r\n\t\treturn new Uint8Array( [ tmpx, tmpy, tmpz ] );\r\n\r\n\t} else if ( bytes == 2 ) {\r\n\r\n\t\tconst tmpx = Math.round( ( x + 1 ) * 0.5 * 65535 );\r\n\t\tconst tmpy = Math.round( ( y + 1 ) * 0.5 * 65535 );\r\n\t\tconst tmpz = Math.round( ( z + 1 ) * 0.5 * 65535 );\r\n\t\treturn new Uint16Array( [ tmpx, tmpy, tmpz ] );\r\n\r\n\t} else {\r\n\r\n\t\tconsole.error( 'number of bytes must be 1 or 2' );\r\n\r\n\t}\r\n\r\n}\r\n\r\n// for `Angles` encoding\r\nfunction anglesEncode( x, y, z ) {\r\n\r\n\tconst normal0 = parseInt( 0.5 * ( 1.0 + Math.atan2( y, x ) / Math.PI ) * 65535 );\r\n\tconst normal1 = parseInt( 0.5 * ( 1.0 + z ) * 65535 );\r\n\treturn new Uint16Array( [ normal0, normal1 ] );\r\n\r\n}\r\n\r\n// for `Octahedron` encoding\r\nfunction octEncodeBest( x, y, z, bytes ) {\r\n\r\n\tlet oct, dec, best, currentCos, bestCos;\r\n\r\n\t// Test various combinations of ceil and floor\r\n\t// to minimize rounding errors\r\n\tbest = oct = octEncodeVec3( x, y, z, 'floor', 'floor' );\r\n\tdec = octDecodeVec2( oct );\r\n\tbestCos = dot( x, y, z, dec );\r\n\r\n\toct = octEncodeVec3( x, y, z, 'ceil', 'floor' );\r\n\tdec = octDecodeVec2( oct );\r\n\tcurrentCos = dot( x, y, z, dec );\r\n\r\n\tif ( currentCos > bestCos ) {\r\n\r\n\t\tbest = oct;\r\n\t\tbestCos = currentCos;\r\n\r\n\t}\r\n\r\n\toct = octEncodeVec3( x, y, z, 'floor', 'ceil' );\r\n\tdec = octDecodeVec2( oct );\r\n\tcurrentCos = dot( x, y, z, dec );\r\n\r\n\tif ( currentCos > bestCos ) {\r\n\r\n\t\tbest = oct;\r\n\t\tbestCos = currentCos;\r\n\r\n\t}\r\n\r\n\toct = octEncodeVec3( x, y, z, 'ceil', 'ceil' );\r\n\tdec = octDecodeVec2( oct );\r\n\tcurrentCos = dot( x, y, z, dec );\r\n\r\n\tif ( currentCos > bestCos ) {\r\n\r\n\t\tbest = oct;\r\n\r\n\t}\r\n\r\n\treturn best;\r\n\r\n\tfunction octEncodeVec3( x0, y0, z0, xfunc, yfunc ) {\r\n\r\n\t\tlet x = x0 / ( Math.abs( x0 ) + Math.abs( y0 ) + Math.abs( z0 ) );\r\n\t\tlet y = y0 / ( Math.abs( x0 ) + Math.abs( y0 ) + Math.abs( z0 ) );\r\n\r\n\t\tif ( z < 0 ) {\r\n\r\n\t\t\tconst tempx = ( 1 - Math.abs( y ) ) * ( x >= 0 ? 1 : - 1 );\r\n\t\t\tconst tempy = ( 1 - Math.abs( x ) ) * ( y >= 0 ? 1 : - 1 );\r\n\r\n\t\t\tx = tempx;\r\n\t\t\ty = tempy;\r\n\r\n\t\t\tlet diff = 1 - Math.abs( x ) - Math.abs( y );\r\n\t\t\tif ( diff > 0 ) {\r\n\r\n\t\t\t\tdiff += 0.001;\r\n\t\t\t\tx += x > 0 ? diff / 2 : - diff / 2;\r\n\t\t\t\ty += y > 0 ? diff / 2 : - diff / 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( bytes == 1 ) {\r\n\r\n\t\t\treturn new Int8Array( [\r\n\t\t\t\tMath[ xfunc ]( x * 127.5 + ( x < 0 ? 1 : 0 ) ),\r\n\t\t\t\tMath[ yfunc ]( y * 127.5 + ( y < 0 ? 1 : 0 ) )\r\n\t\t\t] );\r\n\r\n\t\t}\r\n\r\n\t\tif ( bytes == 2 ) {\r\n\r\n\t\t\treturn new Int16Array( [\r\n\t\t\t\tMath[ xfunc ]( x * 32767.5 + ( x < 0 ? 1 : 0 ) ),\r\n\t\t\t\tMath[ yfunc ]( y * 32767.5 + ( y < 0 ? 1 : 0 ) )\r\n\t\t\t] );\r\n\r\n\t\t}\r\n\r\n\r\n\t}\r\n\r\n\tfunction octDecodeVec2( oct ) {\r\n\r\n\t\tlet x = oct[ 0 ];\r\n\t\tlet y = oct[ 1 ];\r\n\r\n\t\tif ( bytes == 1 ) {\r\n\r\n\t\t\tx /= x < 0 ? 127 : 128;\r\n\t\t\ty /= y < 0 ? 127 : 128;\r\n\r\n\t\t} else if ( bytes == 2 ) {\r\n\r\n\t\t\tx /= x < 0 ? 32767 : 32768;\r\n\t\t\ty /= y < 0 ? 32767 : 32768;\r\n\r\n\t\t}\r\n\r\n\r\n\t\tconst z = 1 - Math.abs( x ) - Math.abs( y );\r\n\r\n\t\tif ( z < 0 ) {\r\n\r\n\t\t\tconst tmpx = x;\r\n\t\t\tx = ( 1 - Math.abs( y ) ) * ( x >= 0 ? 1 : - 1 );\r\n\t\t\ty = ( 1 - Math.abs( tmpx ) ) * ( y >= 0 ? 1 : - 1 );\r\n\r\n\t\t}\r\n\r\n\t\tconst length = Math.sqrt( x * x + y * y + z * z );\r\n\r\n\t\treturn [\r\n\t\t\tx / length,\r\n\t\t\ty / length,\r\n\t\t\tz / length\r\n\t\t];\r\n\r\n\t}\r\n\r\n\tfunction dot( x, y, z, vec3 ) {\r\n\r\n\t\treturn x * vec3[ 0 ] + y * vec3[ 1 ] + z * vec3[ 2 ];\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction quantizedEncode( array, bytes ) {\r\n\r\n\tlet quantized, segments;\r\n\r\n\tif ( bytes == 1 ) {\r\n\r\n\t\tquantized = new Uint8Array( array.length );\r\n\t\tsegments = 255;\r\n\r\n\t} else if ( bytes == 2 ) {\r\n\r\n\t\tquantized = new Uint16Array( array.length );\r\n\t\tsegments = 65535;\r\n\r\n\t} else {\r\n\r\n\t\tconsole.error( 'number of bytes error! ' );\r\n\r\n\t}\r\n\r\n\tconst decodeMat = new Matrix4();\r\n\r\n\tconst min = new Float32Array( 3 );\r\n\tconst max = new Float32Array( 3 );\r\n\r\n\tmin[ 0 ] = min[ 1 ] = min[ 2 ] = Number.MAX_VALUE;\r\n\tmax[ 0 ] = max[ 1 ] = max[ 2 ] = - Number.MAX_VALUE;\r\n\r\n\tfor ( let i = 0; i < array.length; i += 3 ) {\r\n\r\n\t\tmin[ 0 ] = Math.min( min[ 0 ], array[ i + 0 ] );\r\n\t\tmin[ 1 ] = Math.min( min[ 1 ], array[ i + 1 ] );\r\n\t\tmin[ 2 ] = Math.min( min[ 2 ], array[ i + 2 ] );\r\n\t\tmax[ 0 ] = Math.max( max[ 0 ], array[ i + 0 ] );\r\n\t\tmax[ 1 ] = Math.max( max[ 1 ], array[ i + 1 ] );\r\n\t\tmax[ 2 ] = Math.max( max[ 2 ], array[ i + 2 ] );\r\n\r\n\t}\r\n\r\n\tdecodeMat.scale( new Vector3(\r\n\t\t( max[ 0 ] - min[ 0 ] ) / segments,\r\n\t\t( max[ 1 ] - min[ 1 ] ) / segments,\r\n\t\t( max[ 2 ] - min[ 2 ] ) / segments\r\n\t) );\r\n\r\n\tdecodeMat.elements[ 12 ] = min[ 0 ];\r\n\tdecodeMat.elements[ 13 ] = min[ 1 ];\r\n\tdecodeMat.elements[ 14 ] = min[ 2 ];\r\n\r\n\tdecodeMat.transpose();\r\n\r\n\r\n\tconst multiplier = new Float32Array( [\r\n\t\tmax[ 0 ] !== min[ 0 ] ? segments / ( max[ 0 ] - min[ 0 ] ) : 0,\r\n\t\tmax[ 1 ] !== min[ 1 ] ? segments / ( max[ 1 ] - min[ 1 ] ) : 0,\r\n\t\tmax[ 2 ] !== min[ 2 ] ? segments / ( max[ 2 ] - min[ 2 ] ) : 0\r\n\t] );\r\n\r\n\tfor ( let i = 0; i < array.length; i += 3 ) {\r\n\r\n\t\tquantized[ i + 0 ] = Math.floor( ( array[ i + 0 ] - min[ 0 ] ) * multiplier[ 0 ] );\r\n\t\tquantized[ i + 1 ] = Math.floor( ( array[ i + 1 ] - min[ 1 ] ) * multiplier[ 1 ] );\r\n\t\tquantized[ i + 2 ] = Math.floor( ( array[ i + 2 ] - min[ 2 ] ) * multiplier[ 2 ] );\r\n\r\n\t}\r\n\r\n\treturn {\r\n\t\tquantized: quantized,\r\n\t\tdecodeMat: decodeMat\r\n\t};\r\n\r\n}\r\n\r\nfunction quantizedEncodeUV( array, bytes ) {\r\n\r\n\tlet quantized, segments;\r\n\r\n\tif ( bytes == 1 ) {\r\n\r\n\t\tquantized = new Uint8Array( array.length );\r\n\t\tsegments = 255;\r\n\r\n\t} else if ( bytes == 2 ) {\r\n\r\n\t\tquantized = new Uint16Array( array.length );\r\n\t\tsegments = 65535;\r\n\r\n\t} else {\r\n\r\n\t\tconsole.error( 'number of bytes error! ' );\r\n\r\n\t}\r\n\r\n\tconst decodeMat = new Matrix3();\r\n\r\n\tconst min = new Float32Array( 2 );\r\n\tconst max = new Float32Array( 2 );\r\n\r\n\tmin[ 0 ] = min[ 1 ] = Number.MAX_VALUE;\r\n\tmax[ 0 ] = max[ 1 ] = - Number.MAX_VALUE;\r\n\r\n\tfor ( let i = 0; i < array.length; i += 2 ) {\r\n\r\n\t\tmin[ 0 ] = Math.min( min[ 0 ], array[ i + 0 ] );\r\n\t\tmin[ 1 ] = Math.min( min[ 1 ], array[ i + 1 ] );\r\n\t\tmax[ 0 ] = Math.max( max[ 0 ], array[ i + 0 ] );\r\n\t\tmax[ 1 ] = Math.max( max[ 1 ], array[ i + 1 ] );\r\n\r\n\t}\r\n\r\n\tdecodeMat.scale(\r\n\t\t( max[ 0 ] - min[ 0 ] ) / segments,\r\n\t\t( max[ 1 ] - min[ 1 ] ) / segments\r\n\t);\r\n\r\n\tdecodeMat.elements[ 6 ] = min[ 0 ];\r\n\tdecodeMat.elements[ 7 ] = min[ 1 ];\r\n\r\n\tdecodeMat.transpose();\r\n\r\n\tconst multiplier = new Float32Array( [\r\n\t\tmax[ 0 ] !== min[ 0 ] ? segments / ( max[ 0 ] - min[ 0 ] ) : 0,\r\n\t\tmax[ 1 ] !== min[ 1 ] ? segments / ( max[ 1 ] - min[ 1 ] ) : 0\r\n\t] );\r\n\r\n\tfor ( let i = 0; i < array.length; i += 2 ) {\r\n\r\n\t\tquantized[ i + 0 ] = Math.floor( ( array[ i + 0 ] - min[ 0 ] ) * multiplier[ 0 ] );\r\n\t\tquantized[ i + 1 ] = Math.floor( ( array[ i + 1 ] - min[ 1 ] ) * multiplier[ 1 ] );\r\n\r\n\t}\r\n\r\n\treturn {\r\n\t\tquantized: quantized,\r\n\t\tdecodeMat: decodeMat\r\n\t};\r\n\r\n}\r\n\r\n\r\n\r\nexport {\r\n\tcompressNormals,\r\n\tcompressPositions,\r\n\tcompressUvs,\r\n};\r\n", "\r\n/**\r\n * `PackedPhongMaterial` inherited from THREE.MeshPhongMaterial\r\n *\r\n * @param {Object} parameters\r\n */\r\nimport {\r\n\tMeshPhongMaterial,\r\n\tShaderChunk,\r\n\tShaderLib,\r\n\tUniformsUtils,\r\n} from 'three';\r\n\r\nclass PackedPhongMaterial extends MeshPhongMaterial {\r\n\r\n\tconstructor( parameters ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.defines = {};\r\n\t\tthis.type = 'PackedPhongMaterial';\r\n\t\tthis.uniforms = UniformsUtils.merge( [\r\n\r\n\t\t\tShaderLib.phong.uniforms,\r\n\r\n\t\t\t{\r\n\t\t\t\tquantizeMatPos: { value: null },\r\n\t\t\t\tquantizeMatUV: { value: null }\r\n\t\t\t}\r\n\r\n\t\t] );\r\n\r\n\t\tthis.vertexShader = [\r\n\t\t\t'#define PHONG',\r\n\r\n\t\t\t'varying vec3 vViewPosition;',\r\n\r\n\t\t\tShaderChunk.common,\r\n\t\t\tShaderChunk.uv_pars_vertex,\r\n\t\t\tShaderChunk.displacementmap_pars_vertex,\r\n\t\t\tShaderChunk.envmap_pars_vertex,\r\n\t\t\tShaderChunk.color_pars_vertex,\r\n\t\t\tShaderChunk.fog_pars_vertex,\r\n\t\t\tShaderChunk.normal_pars_vertex,\r\n\t\t\tShaderChunk.morphtarget_pars_vertex,\r\n\t\t\tShaderChunk.skinning_pars_vertex,\r\n\t\t\tShaderChunk.shadowmap_pars_vertex,\r\n\t\t\tShaderChunk.logdepthbuf_pars_vertex,\r\n\t\t\tShaderChunk.clipping_planes_pars_vertex,\r\n\r\n\t\t\t`#ifdef USE_PACKED_NORMAL\r\n\t\t\t\t\t#if USE_PACKED_NORMAL == 0\r\n\t\t\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tfloat x = packedNormal.x * 2.0 - 1.0;\r\n\t\t\t\t\t\t\tfloat y = packedNormal.y * 2.0 - 1.0;\r\n\t\t\t\t\t\t\tvec2 scth = vec2(sin(x * PI), cos(x * PI));\r\n\t\t\t\t\t\t\tvec2 scphi = vec2(sqrt(1.0 - y * y), y);\r\n\t\t\t\t\t\t\treturn normalize( vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y) );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t#if USE_PACKED_NORMAL == 1\r\n\t\t\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvec3 v = vec3(packedNormal.xy, 1.0 - abs(packedNormal.x) - abs(packedNormal.y));\r\n\t\t\t\t\t\t\tif (v.z < 0.0)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tv.xy = (1.0 - abs(v.yx)) * vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn normalize(v);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t#if USE_PACKED_NORMAL == 2\r\n\t\t\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvec3 v = (packedNormal * 2.0) - 1.0;\r\n\t\t\t\t\t\t\treturn normalize(v);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t#endif\r\n\t\t\t\t#endif`,\r\n\r\n\t\t\t`#ifdef USE_PACKED_POSITION\r\n\t\t\t\t\t#if USE_PACKED_POSITION == 0\r\n\t\t\t\t\t\tuniform mat4 quantizeMatPos;\r\n\t\t\t\t\t#endif\r\n\t\t\t\t#endif`,\r\n\r\n\t\t\t`#ifdef USE_PACKED_UV\r\n\t\t\t\t\t#if USE_PACKED_UV == 1\r\n\t\t\t\t\t\tuniform mat3 quantizeMatUV;\r\n\t\t\t\t\t#endif\r\n\t\t\t\t#endif`,\r\n\r\n\t\t\t`#ifdef USE_PACKED_UV\r\n\t\t\t\t\t#if USE_PACKED_UV == 0\r\n\t\t\t\t\t\tvec2 decodeUV(vec2 packedUV)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvec2 uv = (packedUV * 2.0) - 1.0;\r\n\t\t\t\t\t\t\treturn uv;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t#if USE_PACKED_UV == 1\r\n\t\t\t\t\t\tvec2 decodeUV(vec2 packedUV)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvec2 uv = ( vec3(packedUV, 1.0) * quantizeMatUV ).xy;\r\n\t\t\t\t\t\t\treturn uv;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t#endif\r\n\t\t\t\t#endif`,\r\n\r\n\t\t\t'void main() {',\r\n\r\n\t\t\tShaderChunk.uv_vertex,\r\n\r\n\t\t\t`#ifdef USE_MAP\r\n\t\t\t\t\t#ifdef USE_PACKED_UV\r\n\t\t\t\t\t\tvMapUv = decodeUV(vMapUv);\r\n\t\t\t\t\t#endif\r\n\t\t\t\t#endif`,\r\n\r\n\t\t\tShaderChunk.color_vertex,\r\n\t\t\tShaderChunk.morphcolor_vertex,\r\n\r\n\t\t\tShaderChunk.beginnormal_vertex,\r\n\r\n\t\t\t`#ifdef USE_PACKED_NORMAL\r\n\t\t\t\t\tobjectNormal = decodeNormal(objectNormal);\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\t#ifdef USE_TANGENT\r\n\t\t\t\t\tvec3 objectTangent = vec3( tangent.xyz );\r\n\t\t\t\t#endif\r\n\t\t\t\t`,\r\n\r\n\t\t\tShaderChunk.morphnormal_vertex,\r\n\t\t\tShaderChunk.skinbase_vertex,\r\n\t\t\tShaderChunk.skinnormal_vertex,\r\n\t\t\tShaderChunk.defaultnormal_vertex,\r\n\t\t\tShaderChunk.normal_vertex,\r\n\r\n\t\t\tShaderChunk.begin_vertex,\r\n\r\n\t\t\t`#ifdef USE_PACKED_POSITION\r\n\t\t\t\t\t#if USE_PACKED_POSITION == 0\r\n\t\t\t\t\t\ttransformed = ( vec4(transformed, 1.0) * quantizeMatPos ).xyz;\r\n\t\t\t\t\t#endif\r\n\t\t\t\t#endif`,\r\n\r\n\t\t\tShaderChunk.morphtarget_vertex,\r\n\t\t\tShaderChunk.skinning_vertex,\r\n\t\t\tShaderChunk.displacementmap_vertex,\r\n\t\t\tShaderChunk.project_vertex,\r\n\t\t\tShaderChunk.logdepthbuf_vertex,\r\n\t\t\tShaderChunk.clipping_planes_vertex,\r\n\r\n\t\t\t'vViewPosition = - mvPosition.xyz;',\r\n\r\n\t\t\tShaderChunk.worldpos_vertex,\r\n\t\t\tShaderChunk.envmap_vertex,\r\n\t\t\tShaderChunk.shadowmap_vertex,\r\n\t\t\tShaderChunk.fog_vertex,\r\n\r\n\t\t\t'}',\r\n\t\t].join( '\\n' );\r\n\r\n\t\t// Use the original MeshPhongMaterial's fragmentShader.\r\n\t\tthis.fragmentShader = ShaderLib.phong.fragmentShader;\r\n\r\n\t\tthis.setValues( parameters );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { PackedPhongMaterial };\r\n"],
  "mappings": "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",
  "names": ["x", "y", "oct", "z"]
}
